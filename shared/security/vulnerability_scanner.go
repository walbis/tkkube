package security

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"
)

// VulnerabilityLevel defines the severity of vulnerabilities
type VulnerabilityLevel string

const (
	VulnLevelCritical VulnerabilityLevel = "critical"
	VulnLevelHigh     VulnerabilityLevel = "high"
	VulnLevelMedium   VulnerabilityLevel = "medium"
	VulnLevelLow      VulnerabilityLevel = "low"
	VulnLevelInfo     VulnerabilityLevel = "info"
)

// VulnerabilityType defines types of vulnerabilities
type VulnerabilityType string

const (
	VulnTypeSecrets             VulnerabilityType = "secrets"
	VulnTypeDependency          VulnerabilityType = "dependency"
	VulnTypeConfiguration       VulnerabilityType = "configuration"
	VulnTypeAuthentication      VulnerabilityType = "authentication"
	VulnTypeAuthorization       VulnerabilityType = "authorization"
	VulnTypeInputValidation     VulnerabilityType = "input_validation"
	VulnTypeCryptography        VulnerabilityType = "cryptography"
	VulnTypeNetworkSecurity     VulnerabilityType = "network_security"
	VulnTypeDataExposure        VulnerabilityType = "data_exposure"
	VulnTypeInjection           VulnerabilityType = "injection"
	VulnTypeDeserialization     VulnerabilityType = "deserialization"
	VulnTypeXSS                 VulnerabilityType = "xss"
	VulnTypeCSRF                VulnerabilityType = "csrf"
	VulnTypePathTraversal       VulnerabilityType = "path_traversal"
	VulnTypePrivilegeEscalation VulnerabilityType = "privilege_escalation"
)

// Vulnerability represents a security vulnerability
type Vulnerability struct {
	ID          string            `json:"id"`
	Type        VulnerabilityType `json:"type"`
	Level       VulnerabilityLevel `json:"level"`
	Title       string            `json:"title"`
	Description string            `json:"description"`
	Impact      string            `json:"impact"`
	Solution    string            `json:"solution"`
	References  []string          `json:"references"`
	CVEID       string            `json:"cve_id,omitempty"`
	CWEIDs      []string          `json:"cwe_ids,omitempty"`
	CVSSScore   float64           `json:"cvss_score,omitempty"`
	Location    VulnLocation      `json:"location"`
	Evidence    string            `json:"evidence,omitempty"`
	Confidence  int               `json:"confidence"`
	FirstSeen   time.Time         `json:"first_seen"`
	LastSeen    time.Time         `json:"last_seen"`
	Status      string            `json:"status"` // new, confirmed, fixed, false_positive
	Metadata    map[string]string `json:"metadata,omitempty"`
}

// VulnLocation specifies where a vulnerability was found
type VulnLocation struct {
	FilePath    string `json:"file_path,omitempty"`
	LineNumber  int    `json:"line_number,omitempty"`
	Column      int    `json:"column,omitempty"`
	Function    string `json:"function,omitempty"`
	Package     string `json:"package,omitempty"`
	Component   string `json:"component,omitempty"`
	URL         string `json:"url,omitempty"`
	Network     string `json:"network,omitempty"`
}

// ScanResult represents the result of a vulnerability scan
type ScanResult struct {
	ScanID          string          `json:"scan_id"`
	Timestamp       time.Time       `json:"timestamp"`
	Duration        time.Duration   `json:"duration"`
	Scanner         string          `json:"scanner"`
	Target          string          `json:"target"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	Summary         ScanSummary     `json:"summary"`
	Metadata        map[string]string `json:"metadata,omitempty"`
}

// ScanSummary provides summary statistics
type ScanSummary struct {
	TotalVulns     int `json:"total_vulnerabilities"`
	CriticalCount  int `json:"critical_count"`
	HighCount      int `json:"high_count"`
	MediumCount    int `json:"medium_count"`
	LowCount       int `json:"low_count"`
	InfoCount      int `json:"info_count"`
	NewVulns       int `json:"new_vulnerabilities"`
	FixedVulns     int `json:"fixed_vulnerabilities"`
	FilesScanned   int `json:"files_scanned"`
	PackagesScanned int `json:"packages_scanned"`
}

// ScanConfig configures vulnerability scanning
type ScanConfig struct {
	Enabled           bool              `yaml:"enabled"`
	Scanners          []string          `yaml:"scanners"`
	ScanInterval      time.Duration     `yaml:"scan_interval"`
	Targets           []string          `yaml:"targets"`
	ExcludePatterns   []string          `yaml:"exclude_patterns"`
	MinSeverity       VulnerabilityLevel `yaml:"min_severity"`
	MaxScanTime       time.Duration     `yaml:"max_scan_time"`
	ReportPath        string            `yaml:"report_path"`
	FailOnVulns       bool              `yaml:"fail_on_vulnerabilities"`
	Dependencies      DependencyScanConfig `yaml:"dependencies"`
	Secrets           SecretsScanConfig    `yaml:"secrets"`
	Configuration     ConfigScanConfig     `yaml:"configuration"`
	NetworkScan       NetworkScanConfig    `yaml:"network"`
}

// DependencyScanConfig configures dependency vulnerability scanning
type DependencyScanConfig struct {
	Enabled         bool     `yaml:"enabled"`
	PackageFiles    []string `yaml:"package_files"`
	DatabasePath    string   `yaml:"database_path"`
	UpdateInterval  time.Duration `yaml:"update_interval"`
	IgnoreDevDeps   bool     `yaml:"ignore_dev_dependencies"`
}

// SecretsScanConfig configures secrets scanning (extends basic config)
type SecretsScanConfig struct {
	Enabled         bool     `yaml:"enabled"`
	Patterns        []string `yaml:"patterns"`
	Exclusions      []string `yaml:"exclusions"`
	EntropyCheck    bool     `yaml:"entropy_check"`
	MinEntropy      float64  `yaml:"min_entropy"`
	ContextLines    int      `yaml:"context_lines"`
}

// ConfigScanConfig configures configuration vulnerability scanning
type ConfigScanConfig struct {
	Enabled         bool     `yaml:"enabled"`
	ConfigFiles     []string `yaml:"config_files"`
	SecurityRules   []string `yaml:"security_rules"`
	BestPractices   bool     `yaml:"best_practices"`
}

// NetworkScanConfig configures network vulnerability scanning
type NetworkScanConfig struct {
	Enabled         bool     `yaml:"enabled"`
	Hosts           []string `yaml:"hosts"`
	Ports           []string `yaml:"ports"`
	TLSCheck        bool     `yaml:"tls_check"`
	CertificateCheck bool    `yaml:"certificate_check"`
}

// VulnerabilityScanner performs comprehensive security scanning
type VulnerabilityScanner struct {
	config          ScanConfig
	logger          Logger
	auditor         *AuditLogger
	secretsManager  *SecretsManager
	inputValidator  *InputValidator
	knownVulns      map[string]*Vulnerability
	scanHistory     []ScanResult
	mu              sync.RWMutex
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(config ScanConfig, logger Logger, auditor *AuditLogger) *VulnerabilityScanner {
	vs := &VulnerabilityScanner{
		config:      config,
		logger:      logger,
		auditor:     auditor,
		knownVulns:  make(map[string]*Vulnerability),
		scanHistory: []ScanResult{},
	}

	// Load vulnerability database
	vs.loadVulnerabilityDatabase()

	// Start periodic scanning if enabled
	if config.Enabled && config.ScanInterval > 0 {
		go vs.startPeriodicScanning()
	}

	return vs
}

// DefaultScanConfig returns default scanning configuration
func DefaultScanConfig() ScanConfig {
	return ScanConfig{
		Enabled:         true,
		Scanners:        []string{"secrets", "dependencies", "configuration", "network"},
		ScanInterval:    24 * time.Hour,
		Targets:         []string{"."},
		ExcludePatterns: []string{"*.git", "node_modules", "vendor", "*.test"},
		MinSeverity:     VulnLevelMedium,
		MaxScanTime:     30 * time.Minute,
		ReportPath:      "/var/log/backup-gitops/vulnerability-scan.json",
		FailOnVulns:     false,
		Dependencies: DependencyScanConfig{
			Enabled:        true,
			PackageFiles:   []string{"package.json", "go.mod", "requirements.txt", "Gemfile", "pom.xml"},
			UpdateInterval: 24 * time.Hour,
			IgnoreDevDeps:  true,
		},
		Secrets: SecretsScanConfig{
			Enabled:      true,
			EntropyCheck: true,
			MinEntropy:   4.5,
			ContextLines: 3,
		},
		Configuration: ConfigScanConfig{
			Enabled:       true,
			ConfigFiles:   []string{"*.yaml", "*.yml", "*.json", "*.conf", "*.cfg", "*.ini"},
			BestPractices: true,
		},
		NetworkScan: NetworkScanConfig{
			Enabled:          true,
			TLSCheck:         true,
			CertificateCheck: true,
		},
	}
}

// PerformScan performs a comprehensive vulnerability scan
func (vs *VulnerabilityScanner) PerformScan(ctx context.Context, targets []string) (*ScanResult, error) {
	scanID := vs.generateScanID()
	startTime := time.Now()

	vs.logger.Info("starting vulnerability scan", map[string]interface{}{
		"scan_id": scanID,
		"targets": targets,
		"scanners": vs.config.Scanners,
	})

	result := &ScanResult{
		ScanID:          scanID,
		Timestamp:       startTime,
		Scanner:         "comprehensive",
		Target:          strings.Join(targets, ","),
		Vulnerabilities: []Vulnerability{},
		Metadata:        make(map[string]string),
	}

	// Create context with timeout
	scanCtx, cancel := context.WithTimeout(ctx, vs.config.MaxScanTime)
	defer cancel()

	var allVulns []Vulnerability

	// Run enabled scanners
	for _, scanner := range vs.config.Scanners {
		vs.logger.Debug("running scanner", map[string]interface{}{
			"scanner": scanner,
			"scan_id": scanID,
		})

		var vulns []Vulnerability
		var err error

		switch scanner {
		case "secrets":
			vulns, err = vs.scanSecrets(scanCtx, targets)
		case "dependencies":
			vulns, err = vs.scanDependencies(scanCtx, targets)
		case "configuration":
			vulns, err = vs.scanConfiguration(scanCtx, targets)
		case "network":
			vulns, err = vs.scanNetwork(scanCtx, targets)
		case "static":
			vulns, err = vs.scanStaticCode(scanCtx, targets)
		default:
			vs.logger.Warn("unknown scanner", map[string]interface{}{
				"scanner": scanner,
			})
			continue
		}

		if err != nil {
			vs.logger.Error("scanner failed", map[string]interface{}{
				"scanner": scanner,
				"error":   err.Error(),
			})
			// Continue with other scanners
		} else {
			allVulns = append(allVulns, vulns...)
		}
	}

	// Filter vulnerabilities by severity
	filteredVulns := vs.filterVulnerabilities(allVulns)
	result.Vulnerabilities = filteredVulns

	// Calculate summary
	result.Summary = vs.calculateSummary(filteredVulns)
	result.Duration = time.Since(startTime)

	// Store scan result
	vs.storeScanResult(result)

	// Log audit event
	vs.auditor.LogSystemEvent("vulnerability_scan_completed", "vulnerability_scanner", "success",
		fmt.Sprintf("Scan completed: %d vulnerabilities found", len(filteredVulns)))

	vs.logger.Info("vulnerability scan completed", map[string]interface{}{
		"scan_id":     scanID,
		"duration":    result.Duration,
		"total_vulns": len(filteredVulns),
		"critical":    result.Summary.CriticalCount,
		"high":        result.Summary.HighCount,
	})

	return result, nil
}

// scanSecrets scans for exposed secrets
func (vs *VulnerabilityScanner) scanSecrets(ctx context.Context, targets []string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	for _, target := range targets {
		if err := filepath.Walk(target, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			// Skip excluded patterns
			if vs.shouldExcludeFile(path) {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}

			// Skip binary files
			if vs.isBinaryFile(path) {
				return nil
			}

			// Scan file for secrets
			fileVulns, err := vs.scanFileForSecrets(path)
			if err != nil {
				vs.logger.Warn("failed to scan file for secrets", map[string]interface{}{
					"file":  path,
					"error": err.Error(),
				})
				return nil
			}

			vulnerabilities = append(vulnerabilities, fileVulns...)
			return nil
		}); err != nil {
			return nil, fmt.Errorf("failed to walk directory %s: %v", target, err)
		}
	}

	return vulnerabilities, nil
}

// scanDependencies scans for vulnerable dependencies
func (vs *VulnerabilityScanner) scanDependencies(ctx context.Context, targets []string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	for _, target := range targets {
		// Find package files
		packageFiles, err := vs.findPackageFiles(target)
		if err != nil {
			continue
		}

		for _, packageFile := range packageFiles {
			vulns, err := vs.scanPackageFile(ctx, packageFile)
			if err != nil {
				vs.logger.Warn("failed to scan package file", map[string]interface{}{
					"file":  packageFile,
					"error": err.Error(),
				})
				continue
			}
			vulnerabilities = append(vulnerabilities, vulns...)
		}
	}

	return vulnerabilities, nil
}

// scanConfiguration scans for configuration vulnerabilities
func (vs *VulnerabilityScanner) scanConfiguration(ctx context.Context, targets []string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	configRules := vs.getConfigurationRules()

	for _, target := range targets {
		configFiles, err := vs.findConfigFiles(target)
		if err != nil {
			continue
		}

		for _, configFile := range configFiles {
			vulns, err := vs.scanConfigFile(configFile, configRules)
			if err != nil {
				vs.logger.Warn("failed to scan config file", map[string]interface{}{
					"file":  configFile,
					"error": err.Error(),
				})
				continue
			}
			vulnerabilities = append(vulnerabilities, vulns...)
		}
	}

	return vulnerabilities, nil
}

// scanNetwork scans for network vulnerabilities
func (vs *VulnerabilityScanner) scanNetwork(ctx context.Context, targets []string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	if !vs.config.NetworkScan.Enabled {
		return vulnerabilities, nil
	}

	// Scan configured hosts
	for _, host := range vs.config.NetworkScan.Hosts {
		vulns, err := vs.scanHost(ctx, host)
		if err != nil {
			vs.logger.Warn("failed to scan host", map[string]interface{}{
				"host":  host,
				"error": err.Error(),
			})
			continue
		}
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

// scanStaticCode performs static code analysis
func (vs *VulnerabilityScanner) scanStaticCode(ctx context.Context, targets []string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	staticRules := vs.getStaticAnalysisRules()

	for _, target := range targets {
		if err := filepath.Walk(target, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			if vs.shouldExcludeFile(path) || vs.isBinaryFile(path) {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}

			vulns, err := vs.scanFileWithRules(path, staticRules)
			if err != nil {
				return nil
			}

			vulnerabilities = append(vulnerabilities, vulns...)
			return nil
		}); err != nil {
			return nil, err
		}
	}

	return vulnerabilities, nil
}

// Helper methods

func (vs *VulnerabilityScanner) scanFileForSecrets(filePath string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	// Use the secrets manager scanner if available
	if vs.secretsManager != nil {
		result, err := vs.secretsManager.ScanFile(filePath)
		if err != nil {
			return nil, err
		}

		// Convert secret matches to vulnerabilities
		for _, match := range result.Matches {
			vuln := Vulnerability{
				ID:          vs.generateVulnID("SECRET", filePath, match.Line),
				Type:        VulnTypeSecrets,
				Level:       vs.severityFromConfidence(match.Confidence),
				Title:       fmt.Sprintf("Exposed %s", match.Type),
				Description: fmt.Sprintf("Potential %s found in source code", match.Type),
				Impact:      "Credential exposure could lead to unauthorized access",
				Solution:    "Remove hardcoded secrets and use secure secret management",
				Location: VulnLocation{
					FilePath:   filePath,
					LineNumber: match.Line,
					Column:     match.Column,
				},
				Evidence:   match.Context,
				Confidence: match.Confidence,
				FirstSeen:  time.Now(),
				LastSeen:   time.Now(),
				Status:     "new",
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) scanPackageFile(ctx context.Context, packageFile string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	// Determine package manager and scan accordingly
	switch {
	case strings.HasSuffix(packageFile, "package.json"):
		vulns, err := vs.scanNPMPackages(ctx, packageFile)
		if err != nil {
			return nil, err
		}
		vulnerabilities = append(vulnerabilities, vulns...)

	case strings.HasSuffix(packageFile, "go.mod"):
		vulns, err := vs.scanGoModules(ctx, packageFile)
		if err != nil {
			return nil, err
		}
		vulnerabilities = append(vulnerabilities, vulns...)

	case strings.HasSuffix(packageFile, "requirements.txt"):
		vulns, err := vs.scanPythonPackages(ctx, packageFile)
		if err != nil {
			return nil, err
		}
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) scanNPMPackages(ctx context.Context, packageFile string) ([]Vulnerability, error) {
	// Run npm audit
	cmd := exec.CommandContext(ctx, "npm", "audit", "--json")
	cmd.Dir = filepath.Dir(packageFile)

	output, err := cmd.Output()
	if err != nil {
		// npm audit returns non-zero on vulnerabilities
		if exitError, ok := err.(*exec.ExitError); ok {
			output = exitError.Stderr
		} else {
			return nil, err
		}
	}

	return vs.parseNPMAuditOutput(output, packageFile)
}

func (vs *VulnerabilityScanner) scanGoModules(ctx context.Context, goModFile string) ([]Vulnerability, error) {
	// Use govulncheck if available
	cmd := exec.CommandContext(ctx, "govulncheck", "-json", "./...")
	cmd.Dir = filepath.Dir(goModFile)

	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	return vs.parseGovulncheckOutput(output, goModFile)
}

func (vs *VulnerabilityScanner) scanPythonPackages(ctx context.Context, reqFile string) ([]Vulnerability, error) {
	// Use safety if available
	cmd := exec.CommandContext(ctx, "safety", "check", "--json", "-r", reqFile)

	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	return vs.parseSafetyOutput(output, reqFile)
}

func (vs *VulnerabilityScanner) scanConfigFile(configFile string, rules []ConfigRule) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	content, err := os.ReadFile(configFile)
	if err != nil {
		return nil, err
	}

	lines := strings.Split(string(content), "\n")

	for lineNum, line := range lines {
		for _, rule := range rules {
			if rule.matches(line) {
				vuln := Vulnerability{
					ID:          vs.generateVulnID("CONFIG", configFile, lineNum+1),
					Type:        VulnTypeConfiguration,
					Level:       rule.Severity,
					Title:       rule.Title,
					Description: rule.Description,
					Impact:      rule.Impact,
					Solution:    rule.Solution,
					Location: VulnLocation{
						FilePath:   configFile,
						LineNumber: lineNum + 1,
					},
					Evidence:   line,
					Confidence: rule.Confidence,
					FirstSeen:  time.Now(),
					LastSeen:   time.Now(),
					Status:     "new",
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) scanHost(ctx context.Context, host string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	// Port scanning
	if len(vs.config.NetworkScan.Ports) > 0 {
		portVulns, err := vs.scanPorts(ctx, host, vs.config.NetworkScan.Ports)
		if err == nil {
			vulnerabilities = append(vulnerabilities, portVulns...)
		}
	}

	// TLS scanning
	if vs.config.NetworkScan.TLSCheck {
		tlsVulns, err := vs.scanTLS(ctx, host)
		if err == nil {
			vulnerabilities = append(vulnerabilities, tlsVulns...)
		}
	}

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) scanPorts(ctx context.Context, host string, ports []string) ([]Vulnerability, error) {
	// Simplified port scanning - in production, use proper network scanning tools
	var vulnerabilities []Vulnerability

	for _, port := range ports {
		// Check if port is open and assess risk
		// This is a simplified example
		_ = host
		_ = port
	}

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) scanTLS(ctx context.Context, host string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	// TLS configuration scanning would be implemented here
	// Check for weak ciphers, protocols, certificate issues
	_ = host

	return vulnerabilities, nil
}

// Helper types and methods

type ConfigRule struct {
	Title       string
	Description string
	Impact      string
	Solution    string
	Pattern     *regexp.Regexp
	Severity    VulnerabilityLevel
	Confidence  int
}

func (r ConfigRule) matches(line string) bool {
	return r.Pattern.MatchString(line)
}

func (vs *VulnerabilityScanner) getConfigurationRules() []ConfigRule {
	return []ConfigRule{
		{
			Title:       "Insecure TLS Configuration",
			Description: "TLS verification is disabled",
			Impact:      "Man-in-the-middle attacks possible",
			Solution:    "Enable TLS verification",
			Pattern:     regexp.MustCompile(`(?i)insecure.*skip.*verify.*true`),
			Severity:    VulnLevelHigh,
			Confidence:  90,
		},
		{
			Title:       "Debug Mode Enabled",
			Description: "Debug mode is enabled in production",
			Impact:      "Information disclosure",
			Solution:    "Disable debug mode in production",
			Pattern:     regexp.MustCompile(`(?i)debug.*true`),
			Severity:    VulnLevelMedium,
			Confidence:  80,
		},
		{
			Title:       "Weak Password Policy",
			Description: "Minimum password length is too short",
			Impact:      "Weak passwords can be easily cracked",
			Solution:    "Increase minimum password length to at least 12 characters",
			Pattern:     regexp.MustCompile(`(?i)password.*min.*length.*[1-7][^0-9]`),
			Severity:    VulnLevelMedium,
			Confidence:  85,
		},
	}
}

func (vs *VulnerabilityScanner) getStaticAnalysisRules() []ConfigRule {
	return []ConfigRule{
		{
			Title:       "SQL Injection Risk",
			Description: "Potential SQL injection vulnerability",
			Impact:      "Database compromise",
			Solution:    "Use parameterized queries",
			Pattern:     regexp.MustCompile(`(?i)sql.*query.*\+.*user.*input`),
			Severity:    VulnLevelHigh,
			Confidence:  75,
		},
		{
			Title:       "Command Injection Risk",
			Description: "Potential command injection vulnerability",
			Impact:      "Remote code execution",
			Solution:    "Validate and sanitize input",
			Pattern:     regexp.MustCompile(`(?i)exec.*\(.*user.*input`),
			Severity:    VulnLevelCritical,
			Confidence:  80,
		},
	}
}

// Parsing methods for different vulnerability scanners

func (vs *VulnerabilityScanner) parseNPMAuditOutput(output []byte, packageFile string) ([]Vulnerability, error) {
	// Parse npm audit JSON output
	var auditResult map[string]interface{}
	if err := json.Unmarshal(output, &auditResult); err != nil {
		return nil, err
	}

	var vulnerabilities []Vulnerability
	// Parse vulnerabilities from npm audit result
	// Implementation would extract vulnerability details

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) parseGovulncheckOutput(output []byte, goModFile string) ([]Vulnerability, error) {
	// Parse govulncheck JSON output
	var vulnerabilities []Vulnerability
	// Implementation would parse Go vulnerability data

	return vulnerabilities, nil
}

func (vs *VulnerabilityScanner) parseSafetyOutput(output []byte, reqFile string) ([]Vulnerability, error) {
	// Parse safety JSON output
	var vulnerabilities []Vulnerability
	// Implementation would parse Python package vulnerabilities

	return vulnerabilities, nil
}

// Utility methods

func (vs *VulnerabilityScanner) generateScanID() string {
	return fmt.Sprintf("scan_%d", time.Now().Unix())
}

func (vs *VulnerabilityScanner) generateVulnID(vulnType, file string, line int) string {
	return fmt.Sprintf("%s_%s_%d_%d", vulnType, filepath.Base(file), line, time.Now().Unix())
}

func (vs *VulnerabilityScanner) shouldExcludeFile(path string) bool {
	for _, pattern := range vs.config.ExcludePatterns {
		if matched, _ := filepath.Match(pattern, filepath.Base(path)); matched {
			return true
		}
		if strings.Contains(path, pattern) {
			return true
		}
	}
	return false
}

func (vs *VulnerabilityScanner) isBinaryFile(path string) bool {
	// Simple binary file detection
	ext := strings.ToLower(filepath.Ext(path))
	binaryExts := []string{".exe", ".dll", ".so", ".dylib", ".a", ".o", ".bin", ".img", ".iso"}
	
	for _, bExt := range binaryExts {
		if ext == bExt {
			return true
		}
	}
	
	// Check file content for binary data
	file, err := os.Open(path)
	if err != nil {
		return false
	}
	defer file.Close()

	buffer := make([]byte, 512)
	n, err := file.Read(buffer)
	if err != nil {
		return false
	}

	// Check for null bytes (common in binary files)
	for i := 0; i < n; i++ {
		if buffer[i] == 0 {
			return true
		}
	}

	return false
}

func (vs *VulnerabilityScanner) findPackageFiles(target string) ([]string, error) {
	var packageFiles []string

	for _, pattern := range vs.config.Dependencies.PackageFiles {
		matches, err := filepath.Glob(filepath.Join(target, pattern))
		if err != nil {
			continue
		}
		packageFiles = append(packageFiles, matches...)
	}

	return packageFiles, nil
}

func (vs *VulnerabilityScanner) findConfigFiles(target string) ([]string, error) {
	var configFiles []string

	for _, pattern := range vs.config.Configuration.ConfigFiles {
		matches, err := filepath.Glob(filepath.Join(target, pattern))
		if err != nil {
			continue
		}
		configFiles = append(configFiles, matches...)
	}

	return configFiles, nil
}

func (vs *VulnerabilityScanner) scanFileWithRules(filePath string, rules []ConfigRule) ([]Vulnerability, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var vulnerabilities []Vulnerability
	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := scanner.Text()

		for _, rule := range rules {
			if rule.matches(line) {
				vuln := Vulnerability{
					ID:          vs.generateVulnID("STATIC", filePath, lineNum),
					Type:        VulnTypeInputValidation, // Default type
					Level:       rule.Severity,
					Title:       rule.Title,
					Description: rule.Description,
					Impact:      rule.Impact,
					Solution:    rule.Solution,
					Location: VulnLocation{
						FilePath:   filePath,
						LineNumber: lineNum,
					},
					Evidence:   line,
					Confidence: rule.Confidence,
					FirstSeen:  time.Now(),
					LastSeen:   time.Now(),
					Status:     "new",
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}

	return vulnerabilities, scanner.Err()
}

func (vs *VulnerabilityScanner) filterVulnerabilities(vulns []Vulnerability) []Vulnerability {
	var filtered []Vulnerability

	severityOrder := map[VulnerabilityLevel]int{
		VulnLevelCritical: 5,
		VulnLevelHigh:     4,
		VulnLevelMedium:   3,
		VulnLevelLow:      2,
		VulnLevelInfo:     1,
	}

	minSeverityValue := severityOrder[vs.config.MinSeverity]

	for _, vuln := range vulns {
		if severityOrder[vuln.Level] >= minSeverityValue {
			filtered = append(filtered, vuln)
		}
	}

	return filtered
}

func (vs *VulnerabilityScanner) calculateSummary(vulns []Vulnerability) ScanSummary {
	summary := ScanSummary{}

	for _, vuln := range vulns {
		summary.TotalVulns++
		switch vuln.Level {
		case VulnLevelCritical:
			summary.CriticalCount++
		case VulnLevelHigh:
			summary.HighCount++
		case VulnLevelMedium:
			summary.MediumCount++
		case VulnLevelLow:
			summary.LowCount++
		case VulnLevelInfo:
			summary.InfoCount++
		}

		if vuln.Status == "new" {
			summary.NewVulns++
		}
	}

	return summary
}

func (vs *VulnerabilityScanner) severityFromConfidence(confidence int) VulnerabilityLevel {
	switch {
	case confidence >= 95:
		return VulnLevelHigh
	case confidence >= 85:
		return VulnLevelMedium
	case confidence >= 70:
		return VulnLevelLow
	default:
		return VulnLevelInfo
	}
}

func (vs *VulnerabilityScanner) storeScanResult(result *ScanResult) {
	vs.mu.Lock()
	defer vs.mu.Unlock()

	vs.scanHistory = append(vs.scanHistory, *result)

	// Keep only last 100 scans
	if len(vs.scanHistory) > 100 {
		vs.scanHistory = vs.scanHistory[1:]
	}

	// Write to report file if configured
	if vs.config.ReportPath != "" {
		vs.writeReportFile(result)
	}
}

func (vs *VulnerabilityScanner) writeReportFile(result *ScanResult) {
	data, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		vs.logger.Error("failed to marshal scan result", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}

	reportDir := filepath.Dir(vs.config.ReportPath)
	os.MkdirAll(reportDir, 0755)

	if err := os.WriteFile(vs.config.ReportPath, data, 0644); err != nil {
		vs.logger.Error("failed to write scan report", map[string]interface{}{
			"error": err.Error(),
			"path":  vs.config.ReportPath,
		})
	}
}

func (vs *VulnerabilityScanner) loadVulnerabilityDatabase() {
	// Load known vulnerabilities from database
	// This would typically load from CVE databases, vendor advisories, etc.
	vs.logger.Info("vulnerability database loaded", map[string]interface{}{
		"known_vulns": len(vs.knownVulns),
	})
}

func (vs *VulnerabilityScanner) startPeriodicScanning() {
	ticker := time.NewTicker(vs.config.ScanInterval)
	defer ticker.Stop()

	for range ticker.C {
		ctx := context.Background()
		_, err := vs.PerformScan(ctx, vs.config.Targets)
		if err != nil {
			vs.logger.Error("periodic scan failed", map[string]interface{}{
				"error": err.Error(),
			})
		}
	}
}

// GetScanHistory returns recent scan history
func (vs *VulnerabilityScanner) GetScanHistory() []ScanResult {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	// Return a copy
	history := make([]ScanResult, len(vs.scanHistory))
	copy(history, vs.scanHistory)
	return history
}

// GetLatestScan returns the most recent scan result
func (vs *VulnerabilityScanner) GetLatestScan() *ScanResult {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	if len(vs.scanHistory) == 0 {
		return nil
	}

	latest := vs.scanHistory[len(vs.scanHistory)-1]
	return &latest
}